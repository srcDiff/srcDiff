### Test 1 ###
ORIGINAL
void KisView2::slotLoadingFinished()
{
	KisImageSP img = image();
	slotImageSizeChanged();

	if (m_d->statusBar) {
		m_d->statusBar->imageSizeChanged(img->width(), img->height());
	}
	m_d->resourceProvider->slotImageSizeChanged();

	m_d->nodeManager->nodesUpdated();

	connectCurrentImage();

	if (img->locked()) {
		// If this is the first view on the image, the image will have been locked
		// so unlock it.
		img->blockSignals(false);
		img->unlock();
	}

	if (KisNodeSP node = img->rootLayer()->firstChild()) {
		m_d->layerBox->setCurrentNode(node);
		m_d->nodeManager->activateNode(node);
	}

	m_d->zoomManager->zoomController()->setZoomMode(KoZoomMode::ZOOM_PAGE);

	updateGUI();
//     dbgUI <<"image finished loading, active layer:" << img->activeLayer() <<", root layer:" << img->rootLayer();

}
END_ORIGINAL

MODIFIED
void KisView2::slotLoadingFinished()
{
	KisImageSP img = image();
	slotImageSizeChanged();

	if (m_d->statusBar) {
		m_d->statusBar->imageSizeChanged(img->width(), img->height());
	}
	m_d->resourceProvider->slotImageSizeChanged();

	m_d->nodeManager->nodesUpdated();

	connectCurrentImage();

	if (img->locked()) {
		// If this is the first view on the image, the image will have been locked
		// so unlock it.
		img->blockSignals(false);
		img->unlock();
	}

	if (KisNodeSP node = img->rootLayer()->firstChild()) {
		m_d->layerBox->setCurrentNode(node);
		m_d->nodeManager->activateNode(node);
	}

	/**
	 * Dirty hack alert
	 */
	m_d->viewConverter->setZoomMode(KoZoomMode::ZOOM_PAGE);
	m_d->zoomManager->zoomController()->setAspectMode(true);

	updateGUI();
//     dbgUI <<"image finished loading, active layer:" << img->activeLayer() <<", root layer:" << img->rootLayer();

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KisView2::slotLoadingFinished':
  #Impact#: #Statement# = #2#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• a #name# change occurred to a #call#
	• a #call chain# was inserted

END_SUMMARY

### Test 2 ###
ORIGINAL
void TextShape::paintComponent(QPainter &painter, const KoViewConverter &converter)
{
	p.addRect(converter.documentToView(QRectF(QPointF(), size())));
}
END_ORIGINAL

MODIFIED
void TextShape::paintComponent(QPainter &painter, const KoViewConverter &converter)
{
	p.addRect(QRectF(QPointF(), size()));
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'TextShape::paintComponent':
  #Impact#: #Statement# = #1#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• an #argument# was modified

END_SUMMARY

### Test 3 ###
ORIGINAL
void TextShape::paintComponent(QPainter &painter, const KoViewConverter &converter)
{
	p.addRect(QRectF(QPointF(), size()));
}
END_ORIGINAL

MODIFIED
void TextShape::paintComponent(QPainter &painter, const KoViewConverter &converter)
{
	p.addRect(converter.documentToView(QRectF(QPointF(), size())));
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'TextShape::paintComponent':
  #Impact#: #Statement# = #1#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• an #argument# was modified

END_SUMMARY

### Test 4 ###
ORIGINAL
KoFallBackColorTransformation::KoFallBackColorTransformation(KoColorConversionTransformation* _csToFallBack, KoColorConversionTransformation* _fallBackToCs, KoColorTransformation* _transfo) : d(new Private)
{
    Q_ASSERT(*_csToFallBack->srcColorSpace() == *_fallBackToCs->dstColorSpace());
    Q_ASSERT(*_fallBackToCs->srcColorSpace() == *_csToFallBack->dstColorSpace());
    d->fallBackColorSpace = _fallBackToCs->dstColorSpace();
    d->csToFallBack = _csToFallBack;
    d->fallBackToCs = _fallBackToCs;
    d->csToFallBackCache = 0;
    d->fallBackToCsCache = 0;
    d->colorTransformation = _transfo;
    d->buff = 0;
    d->buffSize = 0;
}
END_ORIGINAL

MODIFIED
KoFallBackColorTransformation::KoFallBackColorTransformation(KoColorConversionTransformation* _csToFallBack, KoColorConversionTransformation* _fallBackToCs, KoColorTransformation* _transfo) : d(new Private)
{
    Q_ASSERT(*_csToFallBack->srcColorSpace() == *_fallBackToCs->dstColorSpace());
    Q_ASSERT(*_fallBackToCs->srcColorSpace() == *_csToFallBack->dstColorSpace());
    d->fallBackColorSpace = _fallBackToCs->srcColorSpace();
    d->csToFallBack = _csToFallBack;
    d->fallBackToCs = _fallBackToCs;
    d->csToFallBackCache = 0;
    d->fallBackToCsCache = 0;
    d->colorTransformation = _transfo;
    d->buff = 0;
    d->buffSize = 0;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• constructor 'KoFallBackColorTransformation::KoFallBackColorTransformation':
  #Impact#: #Statement# = #1#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• a #call# was renamed

END_SUMMARY

### Test 5 ###
ORIGINAL
void KisView2::createGUI()
{

    m_d->layerBox = qobject_cast<KisLayerBox*>(createDockWidget(&layerboxFactory));

    show();

    connect(m_d->layerBox, SIGNAL(sigRequestNewNode(const QString &)),
            m_d->nodeManager, SLOT(createNode(const QString &)));

    connect(m_d->layerBox, SIGNAL(sigRequestNodeProperties(KisNodeSP)),
            m_d->nodeManager, SLOT(nodeProperties(KisNodeSP)));

    connect(m_d->layerBox, SIGNAL(sigOpacityChanged(qreal, bool)),
            m_d->nodeManager, SLOT(nodeOpacityChanged(qreal, bool)));

    connect(m_d->layerBox, SIGNAL(sigItemComposite(const KoCompositeOp*)),
            m_d->nodeManager, SLOT(nodeCompositeOpChanged(const KoCompositeOp*)));

    connect(m_d->nodeManager, SIGNAL(sigNodeActivated(KisNodeSP)),
            m_d->resourceProvider, SLOT(slotNodeActivated(KisNodeSP)));
}
END_ORIGINAL

MODIFIED
void KisView2::createGUI()
{

    createDockWidget(&layerboxFactory);

    show();

    connect(m_d->nodeManager, SIGNAL(sigNodeActivated(KisNodeSP)),
            m_d->resourceProvider, SLOT(slotNodeActivated(KisNodeSP)));
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KisView2::createGUI':
  #Impact#: #Statement# = #5#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• an #expression# was modified
	• 4 #calls# were deleted

END_SUMMARY

### Test 6 ###
ORIGINAL
void f() {

	a->b(c, 0);

}
END_ORIGINAL

MODIFIED
void f() {

	a->b(d,  1);

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact#: #Statement# = #1#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• 2 #arguments# were modified

END_SUMMARY

### Test 7 ###
ORIGINAL
void f() {

	e->f(g + h);

}
END_ORIGINAL

MODIFIED
void f() {

	e->f(g - i);	

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact#: #Statement# = #1#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• an #argument# was modified

END_SUMMARY


### Test 8 ###
ORIGINAL
void f() {

    d->a = false;

}
END_ORIGINAL

MODIFIED
void f() {

    d->b(false);

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact#: #Statement# = #1#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• an #expression# was modified

END_SUMMARY

### Test 9 ###
ORIGINAL
void TextShape::paintComponent(QPainter &painter, const KoViewConverter &converter)
{
    if (background()) {
        QPainterPath p;
        p.addRect(converter.documentToView(QRectF(QPointF(), size())));
        background()->paint(painter, p);
    }
    QTextDocument *doc = m_textShapeData->document();
    Q_ASSERT(doc);
    KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(doc->documentLayout());
    if (m_textShapeData->endPosition() < 0) { // not layouted yet.
        if (lay == 0)
            kWarning(32500) << "Painting shape that doesn't have a kotext doc-layout, which can't work";
        else if (! lay->hasLayouter())
            lay->setLayout(new Layout(lay));
        return;
    }
    Q_ASSERT(lay);
    applyConversion(painter, converter);
    QAbstractTextDocumentLayout::PaintContext pc;
    KoTextDocumentLayout::PaintContext context;
    context.textContext = pc;
    context.viewConverter = &converter;

    QRectF rect(0, 0, size().width(), size().height());
    rect.adjust(-5, 0, 5, 0);
    painter.setClipRect(rect, Qt::IntersectClip);
    painter.save();
    painter.translate(0, -m_textShapeData->documentOffset());
    lay->draw(&painter, context);
    painter.restore();

    if (m_footnotes) {
        painter.translate(0, size().height() - m_footnotes->size().height());
        m_footnotes->documentLayout()->draw(&painter, pc);
    }
}
END_ORIGINAL

MODIFIED
void TextShape::paintComponent(QPainter &painter, const KoViewConverter &converter)
{
    applyConversion(painter, converter);
    if (background()) {
        QPainterPath p;
        p.addRect(QRectF(QPointF(), size()));
        background()->paint(painter, p);
    }
    QTextDocument *doc = m_textShapeData->document();
    Q_ASSERT(doc);
    KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(doc->documentLayout());
    if (m_textShapeData->endPosition() < 0) { // not layouted yet.
        if (lay == 0)
            kWarning(32500) << "Painting shape that doesn't have a kotext doc-layout, which can't work";
        else if (! lay->hasLayouter())
            lay->setLayout(new Layout(lay));
        return;
    }
    Q_ASSERT(lay);
    QAbstractTextDocumentLayout::PaintContext pc;
    KoTextDocumentLayout::PaintContext context;
    context.textContext = pc;
    context.viewConverter = &converter;

    QRectF rect(0, 0, size().width(), size().height());
    rect.adjust(-5, 0, 5, 0);
    painter.setClipRect(rect, Qt::IntersectClip);
    painter.save();
    painter.translate(0, -m_textShapeData->documentOffset());
    lay->draw(&painter, context);
    painter.restore();

    if (m_footnotes) {
        painter.translate(0, size().height() - m_footnotes->size().height());
        m_footnotes->documentLayout()->draw(&painter, pc);
    }
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'TextShape::paintComponent':
  #Impact#: #Statement# = #4#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• a #call# was moved
	• an #argument# was modified

END_SUMMARY

### Test 10 ###
ORIGINAL
void f() {

    std::cerr << foo << '\n';
    a;
    std::cerr << foo << '\n';

}
END_ORIGINAL

MODIFIED
void f() {

    a;
    std::cerr << bar << '\n';
    std::cerr << foobar << '\n';

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact#: #Statement# = #3#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• a #print# was deleted
	• a #print# was modified
	• a #print# was inserted

END_SUMMARY
