### Test 1 ###
ORIGINAL
QWidget * KoZoomAction::createWidget( QWidget * _parent )
{
	// create the custom widget only if we add the action to the status bar
	if( ! qobject_cast<QStatusBar*>(_parent) )
		return KSelectAction::createWidget(_parent);

	QWidget * group = new QWidget(_parent);
	QHBoxLayout *layout = new QHBoxLayout(group);
	layout->setSizeConstraint(QLayout::SetFixedSize);
	layout->setMargin(0);
	layout->setSpacing(0);

	// this is wrong; createWidget() implies this is a factory method, so we should be able to be called
	// multiple times without problems.  The 'new' here means we can't do that.
	// TODO refactor this method to use connections instead of d-pointer members to communicate so it becomes reentrant.
	d->input = new KoZoomInput(group);
	regenerateItems( d->effectiveZoom, true );
	connect(d->input, SIGNAL(zoomLevelChanged(const QString&)), this, SLOT(triggered(const QString&)));
	layout->addWidget(d->input);

	d->slider = new QSlider(Qt::Horizontal);
	d->slider->setToolTip(i18n("Zoom"));
	d->slider->setMinimum(0);
	d->slider->setMaximum(32);
	d->slider->setValue(16);
	d->slider->setSingleStep(1);
	d->slider->setPageStep(1);
	d->slider->setMinimumWidth(80);
	d->slider->setMaximumWidth(80);
	layout->addWidget(d->slider);

	if (d->specialButtons & AspectMode) {
		QToolButton * aspectButton = new QToolButton(group);
		aspectButton->setIcon(KIcon("zoom-pixels").pixmap(22));
		aspectButton->setCheckable(true);
		aspectButton->setChecked(true);
		aspectButton->setAutoRaise(true);
		aspectButton->setToolTip(i18n("Use same aspect as pixels"));
		connect(aspectButton, SIGNAL(toggled(bool)), this, SIGNAL(aspectModeChanged(bool)));
		layout->addWidget(aspectButton);
	}
	if (d->specialButtons & ZoomToSelection) {
		QToolButton * zoomToSelectionButton = new QToolButton(group);
		zoomToSelectionButton->setIcon(KIcon("zoom-selection").pixmap(22));
		zoomToSelectionButton->setAutoRaise(true);
		zoomToSelectionButton->setToolTip(i18n("Zoom to Selection"));
		connect(zoomToSelectionButton, SIGNAL(clicked(bool)), this, SIGNAL(zoomedToSelection()));
		layout->addWidget(zoomToSelectionButton);
	}
	if (d->specialButtons & ZoomToAll) {
		QToolButton * zoomToAllButton = new QToolButton(group);
		zoomToAllButton->setIcon(KIcon("zoom-all").pixmap(22));
		zoomToAllButton->setAutoRaise(true);
		zoomToAllButton->setToolTip(i18n("Zoom to All"));
		connect(zoomToAllButton, SIGNAL(clicked(bool)), this, SIGNAL(zoomedToAll()));
		layout->addWidget(zoomToAllButton);
	}

	connect(d->slider, SIGNAL(valueChanged(int)), this, SLOT(sliderValueChanged(int)));

	return group;
}
END_ORIGINAL

MODIFIED
QWidget * KoZoomAction::createWidget( QWidget * _parent )
{
	// create the custom widget only if we add the action to the status bar
	if( ! qobject_cast<QStatusBar*>(_parent) )
		return KSelectAction::createWidget(_parent);

	QWidget * group = new QWidget(_parent);
	QHBoxLayout *layout = new QHBoxLayout(group);
	layout->setSizeConstraint(QLayout::SetFixedSize);
	layout->setMargin(0);
	layout->setSpacing(0);

	// this is wrong; createWidget() implies this is a factory method, so we should be able to be called
	// multiple times without problems.  The 'new' here means we can't do that.
	// TODO refactor this method to use connections instead of d-pointer members to communicate so it becomes reentrant.
	d->input = new KoZoomInput(group);
	regenerateItems( d->effectiveZoom, true );
	connect(d->input, SIGNAL(zoomLevelChanged(const QString&)), this, SLOT(triggered(const QString&)));
	layout->addWidget(d->input);

	d->slider = new QSlider(Qt::Horizontal);
	d->slider->setToolTip(i18n("Zoom"));
	d->slider->setMinimum(0);
	d->slider->setMaximum(32);
	d->slider->setValue(16);
	d->slider->setSingleStep(1);
	d->slider->setPageStep(1);
	d->slider->setMinimumWidth(80);
	d->slider->setMaximumWidth(80);
	layout->addWidget(d->slider);

	if (d->specialButtons & AspectMode) {
		d->aspectButton = new QToolButton(group);
		d->aspectButton->setIcon(KIcon("zoom-pixels").pixmap(22));
		d->aspectButton->setCheckable(true);
		d->aspectButton->setChecked(true);
		d->aspectButton->setAutoRaise(true);
		d->aspectButton->setToolTip(i18n("Use same aspect as pixels"));
		connect(d->aspectButton, SIGNAL(toggled(bool)), this, SIGNAL(aspectModeChanged(bool)));
		layout->addWidget(d->aspectButton);
	}
	if (d->specialButtons & ZoomToSelection) {
		QToolButton * zoomToSelectionButton = new QToolButton(group);
		zoomToSelectionButton->setIcon(KIcon("zoom-selection").pixmap(22));
		zoomToSelectionButton->setAutoRaise(true);
		zoomToSelectionButton->setToolTip(i18n("Zoom to Selection"));
		connect(zoomToSelectionButton, SIGNAL(clicked(bool)), this, SIGNAL(zoomedToSelection()));
		layout->addWidget(zoomToSelectionButton);
	}
	if (d->specialButtons & ZoomToAll) {
		QToolButton * zoomToAllButton = new QToolButton(group);
		zoomToAllButton->setIcon(KIcon("zoom-all").pixmap(22));
		zoomToAllButton->setAutoRaise(true);
		zoomToAllButton->setToolTip(i18n("Zoom to All"));
		connect(zoomToAllButton, SIGNAL(clicked(bool)), this, SIGNAL(zoomedToAll()));
		layout->addWidget(zoomToAllButton);
	}

	connect(d->slider, SIGNAL(valueChanged(int)), this, SLOT(sliderValueChanged(int)));

	return group;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KoZoomAction::createWidget':
  #Impact# = #10# Statements	#Other# = #0#	#Cyclomatic# = #0#
	• name change from 'aspectButton' to 'd->aspectButton'
	• a #declaration# was replaced with an #assignment#

END_SUMMARY

### Test 2 ###
ORIGINAL
void f() {

	a->b(c);

}
END_ORIGINAL

MODIFIED
void f() {

	a->b(d);

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact# = #1# Statement	#Other# = #0#	#Cyclomatic# = #0#
	• 'c' was renamed to 'd'

END_SUMMARY

### Test 3 ###
ORIGINAL
RotateImage::RotateImage(QObject *parent, const QStringList &)
        : KParts::Plugin(parent)
{
    if (parent->inherits("KisView2")) {
        action  = new KAction(i18n("&Rotate Layer..."), this);
        actionCollection()->addAction("rotatelayer", action);
        connect(action, SIGNAL(triggered()), this, SLOT(slotRotateLayer()));

        action  = new KAction(i18nc("rotate the layer 180 degrees", "1&80Â°"), this);
        actionCollection()->addAction("rotateLayer180", action);
        connect(action, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayer180()));

        action  = new KAction(KIcon("object-rotate-right"), i18nc("rotate the layer 90 degrees to the right", "Right 90Â°"), this);
        actionCollection()->addAction("rotateLayerCW90", action);
        connect(action, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerRight90()));

        action  = new KAction(KIcon("object-rotate-left"), i18nc("rotate the layer 90 degrees to the left", "Left 90Â°"), this);
        actionCollection()->addAction("rotateLayerCCW90", action);
        connect(action, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerLeft90()));
    }
}
END_ORIGINAL

MODIFIED
RotateImage::RotateImage(QObject *parent, const QStringList &)
        : KParts::Plugin(parent)
{
    if (parent->inherits("KisView2")) {
        m_rotateLayerAction  = new KAction(i18n("&Rotate Layer..."), this);
        actionCollection()->addAction("rotatelayer", m_rotateLayerAction);
        connect(m_rotateLayerAction, SIGNAL(triggered()), this, SLOT(slotRotateLayer()));

        m_rotate90LayerAction  = new KAction(i18nc("rotate the layer 180 degrees", "1&80Â°"), this);
        actionCollection()->addAction("rotateLayer180", m_rotate90LayerAction);
        connect(m_rotate90LayerAction, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayer180()));

        m_rotate180LayerAction  = new KAction(KIcon("object-rotate-right"), i18nc("rotate the layer 90 degrees to the right", "Right 90Â°"), this);
        actionCollection()->addAction("rotateLayerCW90", m_rotate180LayerAction);
        connect(m_rotate180LayerAction, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerRight90()));

        m_rotate270LayerAction  = new KAction(KIcon("object-rotate-left"), i18nc("rotate the layer 90 degrees to the left", "Left 90Â°"), this);
        actionCollection()->addAction("rotateLayerCCW90", m_rotate270LayerAction);
        connect(m_rotate270LayerAction, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerLeft90()));

        connect(m_view->resourceProvider(), SIGNAL(sigNodeChanged(const KisNodeSP)), SLOT(slotNodeChanged(KisNodeSP)));
    }
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• constructor 'RotateImage::RotateImage':
  #Impact# = #14# Statements	#Other# = #0#	#Cyclomatic# = #0#
	• 'action' was renamed to 'm_rotate180LayerAction'
	• 'action' was renamed to 'm_rotate270LayerAction'
	• 'action' was renamed to 'm_rotate90LayerAction'
	• 'action' was renamed to 'm_rotateLayerAction'
	• a #call# was inserted

END_SUMMARY
