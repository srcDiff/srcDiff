### Test 1 ###
ORIGINAL
QWidget * KoZoomAction::createWidget( QWidget * _parent )
{
	// create the custom widget only if we add the action to the status bar
	if( ! qobject_cast<QStatusBar*>(_parent) )
		return KSelectAction::createWidget(_parent);

	QWidget * group = new QWidget(_parent);
	QHBoxLayout *layout = new QHBoxLayout(group);
	layout->setSizeConstraint(QLayout::SetFixedSize);
	layout->setMargin(0);
	layout->setSpacing(0);

	// this is wrong; createWidget() implies this is a factory method, so we should be able to be called
	// multiple times without problems.  The 'new' here means we can't do that.
	// TODO refactor this method to use connections instead of d-pointer members to communicate so it becomes reentrant.
	d->input = new KoZoomInput(group);
	regenerateItems( d->effectiveZoom, true );
	connect(d->input, SIGNAL(zoomLevelChanged(const QString&)), this, SLOT(triggered(const QString&)));
	layout->addWidget(d->input);

	d->slider = new QSlider(Qt::Horizontal);
	d->slider->setToolTip(i18n("Zoom"));
	d->slider->setMinimum(0);
	d->slider->setMaximum(32);
	d->slider->setValue(16);
	d->slider->setSingleStep(1);
	d->slider->setPageStep(1);
	d->slider->setMinimumWidth(80);
	d->slider->setMaximumWidth(80);
	layout->addWidget(d->slider);

	if (d->specialButtons & AspectMode) {
		QToolButton * aspectButton = new QToolButton(group);
		aspectButton->setIcon(KIcon("zoom-pixels").pixmap(22));
		aspectButton->setCheckable(true);
		aspectButton->setChecked(true);
		aspectButton->setAutoRaise(true);
		aspectButton->setToolTip(i18n("Use same aspect as pixels"));
		connect(aspectButton, SIGNAL(toggled(bool)), this, SIGNAL(aspectModeChanged(bool)));
		layout->addWidget(aspectButton);
	}
	if (d->specialButtons & ZoomToSelection) {
		QToolButton * zoomToSelectionButton = new QToolButton(group);
		zoomToSelectionButton->setIcon(KIcon("zoom-selection").pixmap(22));
		zoomToSelectionButton->setAutoRaise(true);
		zoomToSelectionButton->setToolTip(i18n("Zoom to Selection"));
		connect(zoomToSelectionButton, SIGNAL(clicked(bool)), this, SIGNAL(zoomedToSelection()));
		layout->addWidget(zoomToSelectionButton);
	}
	if (d->specialButtons & ZoomToAll) {
		QToolButton * zoomToAllButton = new QToolButton(group);
		zoomToAllButton->setIcon(KIcon("zoom-all").pixmap(22));
		zoomToAllButton->setAutoRaise(true);
		zoomToAllButton->setToolTip(i18n("Zoom to All"));
		connect(zoomToAllButton, SIGNAL(clicked(bool)), this, SIGNAL(zoomedToAll()));
		layout->addWidget(zoomToAllButton);
	}

	connect(d->slider, SIGNAL(valueChanged(int)), this, SLOT(sliderValueChanged(int)));

	return group;
}
END_ORIGINAL

MODIFIED
QWidget * KoZoomAction::createWidget( QWidget * _parent )
{
	// create the custom widget only if we add the action to the status bar
	if( ! qobject_cast<QStatusBar*>(_parent) )
		return KSelectAction::createWidget(_parent);

	QWidget * group = new QWidget(_parent);
	QHBoxLayout *layout = new QHBoxLayout(group);
	layout->setSizeConstraint(QLayout::SetFixedSize);
	layout->setMargin(0);
	layout->setSpacing(0);

	// this is wrong; createWidget() implies this is a factory method, so we should be able to be called
	// multiple times without problems.  The 'new' here means we can't do that.
	// TODO refactor this method to use connections instead of d-pointer members to communicate so it becomes reentrant.
	d->input = new KoZoomInput(group);
	regenerateItems( d->effectiveZoom, true );
	connect(d->input, SIGNAL(zoomLevelChanged(const QString&)), this, SLOT(triggered(const QString&)));
	layout->addWidget(d->input);

	d->slider = new QSlider(Qt::Horizontal);
	d->slider->setToolTip(i18n("Zoom"));
	d->slider->setMinimum(0);
	d->slider->setMaximum(32);
	d->slider->setValue(16);
	d->slider->setSingleStep(1);
	d->slider->setPageStep(1);
	d->slider->setMinimumWidth(80);
	d->slider->setMaximumWidth(80);
	layout->addWidget(d->slider);

	if (d->specialButtons & AspectMode) {
		d->aspectButton = new QToolButton(group);
		d->aspectButton->setIcon(KIcon("zoom-pixels").pixmap(22));
		d->aspectButton->setCheckable(true);
		d->aspectButton->setChecked(true);
		d->aspectButton->setAutoRaise(true);
		d->aspectButton->setToolTip(i18n("Use same aspect as pixels"));
		connect(d->aspectButton, SIGNAL(toggled(bool)), this, SIGNAL(aspectModeChanged(bool)));
		layout->addWidget(d->aspectButton);
	}
	if (d->specialButtons & ZoomToSelection) {
		QToolButton * zoomToSelectionButton = new QToolButton(group);
		zoomToSelectionButton->setIcon(KIcon("zoom-selection").pixmap(22));
		zoomToSelectionButton->setAutoRaise(true);
		zoomToSelectionButton->setToolTip(i18n("Zoom to Selection"));
		connect(zoomToSelectionButton, SIGNAL(clicked(bool)), this, SIGNAL(zoomedToSelection()));
		layout->addWidget(zoomToSelectionButton);
	}
	if (d->specialButtons & ZoomToAll) {
		QToolButton * zoomToAllButton = new QToolButton(group);
		zoomToAllButton->setIcon(KIcon("zoom-all").pixmap(22));
		zoomToAllButton->setAutoRaise(true);
		zoomToAllButton->setToolTip(i18n("Zoom to All"));
		connect(zoomToAllButton, SIGNAL(clicked(bool)), this, SIGNAL(zoomedToAll()));
		layout->addWidget(zoomToAllButton);
	}

	connect(d->slider, SIGNAL(valueChanged(int)), this, SLOT(sliderValueChanged(int)));

	return group;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KoZoomAction::createWidget':
  #Impact#: #Statement# = #10#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• name change from 'aspectButton' to 'd->aspectButton'
	• a #declaration# was replaced with an #assignment#

END_SUMMARY

### Test 2 ###
ORIGINAL
void f() {

	a->b(c);

}
END_ORIGINAL

MODIFIED
void f() {

	a->b(d);

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact#: #Statement# = #1#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• name change from 'c' to 'd'

END_SUMMARY

### Test 3 ###
ORIGINAL
RotateImage::RotateImage(QObject *parent, const QStringList &)
        : KParts::Plugin(parent)
{
    if (parent->inherits("KisView2")) {

    	KAction *action  = new KAction(i18n("&Rotate Image..."), this);

        action  = new KAction(i18n("&Rotate Layer..."), this);
        actionCollection()->addAction("rotatelayer", action);
        connect(action, SIGNAL(triggered()), this, SLOT(slotRotateLayer()));

        action  = new KAction(i18nc("rotate the layer 180 degrees", "1&80°"), this);
        actionCollection()->addAction("rotateLayer180", action);
        connect(action, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayer180()));

        action  = new KAction(KIcon("object-rotate-right"), i18nc("rotate the layer 90 degrees to the right", "Right 90°"), this);
        actionCollection()->addAction("rotateLayerCW90", action);
        connect(action, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerRight90()));

        action  = new KAction(KIcon("object-rotate-left"), i18nc("rotate the layer 90 degrees to the left", "Left 90°"), this);
        actionCollection()->addAction("rotateLayerCCW90", action);
        connect(action, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerLeft90()));
    }
}
END_ORIGINAL

MODIFIED
RotateImage::RotateImage(QObject *parent, const QStringList &)
        : KParts::Plugin(parent)
{
    if (parent->inherits("KisView2")) {

    	KAction *action  = new KAction(i18n("&Rotate Image..."), this);

        m_rotateLayerAction  = new KAction(i18n("&Rotate Layer..."), this);
        actionCollection()->addAction("rotatelayer", m_rotateLayerAction);
        connect(m_rotateLayerAction, SIGNAL(triggered()), this, SLOT(slotRotateLayer()));

        m_rotate90LayerAction  = new KAction(i18nc("rotate the layer 180 degrees", "1&80°"), this);
        actionCollection()->addAction("rotateLayer180", m_rotate90LayerAction);
        connect(m_rotate90LayerAction, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayer180()));

        m_rotate180LayerAction  = new KAction(KIcon("object-rotate-right"), i18nc("rotate the layer 90 degrees to the right", "Right 90°"), this);
        actionCollection()->addAction("rotateLayerCW90", m_rotate180LayerAction);
        connect(m_rotate180LayerAction, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerRight90()));

        m_rotate270LayerAction  = new KAction(KIcon("object-rotate-left"), i18nc("rotate the layer 90 degrees to the left", "Left 90°"), this);
        actionCollection()->addAction("rotateLayerCCW90", m_rotate270LayerAction);
        connect(m_rotate270LayerAction, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerLeft90()));

        connect(m_view->resourceProvider(), SIGNAL(sigNodeChanged(const KisNodeSP)), SLOT(slotNodeChanged(KisNodeSP)));
    }
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• constructor 'RotateImage::RotateImage':
  #Impact#: #Statement# = #14#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• name change from 'action' to 'm_rotate180LayerAction'
	• name change from 'action' to 'm_rotate270LayerAction'
	• name change from 'action' to 'm_rotate90LayerAction'
	• name change from 'action' to 'm_rotateLayerAction'
	• a #call# was inserted

END_SUMMARY

### Test 4 ###
ORIGINAL
void f() {

	int foo = 0;
	if(1) {

		int bar = foo + 0;

	}

}
END_ORIGINAL

MODIFIED
void f() {

	int foobar = 0;
	if(1) {

		int bar = foobar + 0;

	}

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact#: #Statement# = #3#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• 'foo' was renamed to 'foobar'

END_SUMMARY

### Test 5 ###
ORIGINAL
KisFilterOption::KisFilterOption()
        : KisPaintOpOption(i18n("Filter"))
{
    m_checkable = false;
    m_currentFilterConfigWidget = 0;

    m_optionsWidget = new KisFilterOptionWidget;
    m_optionsWidget->hide();
    setConfigurationPage(m_optionsWidget);

    m_layout = new QGridLayout( m_optionsWidget->grpFilterOptions );

    // Check which filters support painting
    QList<KoID> l = KisFilterRegistry::instance()->listKeys();
    QList<KoID> l2;
    QList<KoID>::iterator it;
    for (it = l.begin(); it !=  l.end(); ++it) {
        KisFilterSP f = KisFilterRegistry::instance()->value((*it).id());
        if (f->supportsPainting()) {
            l2.push_back(*it);
        }
    }
    m_optionsWidget->filtersList->setIDList(l2);
    connect(m_optionsWidget->filtersList, SIGNAL(activated(const KoID &)), SLOT(setCurrentFilter(const KoID &)));
    if (!l2.empty()) {
        setCurrentFilter(l2.first());
    }


}
END_ORIGINAL

MODIFIED
KisFilterOption::KisFilterOption()
        : KisPaintOpOption(i18n("Filter"))
{
    m_checkable = false;
    m_currentFilterConfigWidget = 0;

    m_options = new KisFilterOptionWidget;
    m_options->hide();
    setConfigurationPage(m_options);

    m_layout = new QGridLayout( m_options->grpFilterOptions );

    // Check which filters support painting
    QList<KoID> l = KisFilterRegistry::instance()->listKeys();
    QList<KoID> l2;
    QList<KoID>::iterator it;
    for (it = l.begin(); it !=  l.end(); ++it) {
        KisFilterSP f = KisFilterRegistry::instance()->value((*it).id());
        if (f->supportsPainting()) {
            l2.push_back(*it);
        }
    }
    m_options->filtersList->setIDList(l2);
    connect(m_options->filtersList, SIGNAL(activated(const KoID &)), SLOT(setCurrentFilter(const KoID &)));
    if (!l2.empty()) {
        setCurrentFilter(l2.first());
    }


}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• constructor 'KisFilterOption::KisFilterOption':
  #Impact#: #Statement# = #6#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• name change from 'm_optionsWidget' to 'm_options'

END_SUMMARY

### Test 6 ###
ORIGINAL
void f() { 

    int foo = bar;

    if(1) {

        foo = bar;
        blah;

    }

}
END_ORIGINAL

MODIFIED
void f() { 

    int foo = foobar;

    if(1) {

        foo = foobar;
        blah;

    }

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact#: #Statement# = #3#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• name change from 'bar' to 'foobar'

END_SUMMARY

### Test 7 ###
ORIGINAL
void f() { 

    int foo = a->bar->f();

    if(1) {

        foo = a->bar->f();
        blah;

    }

}
END_ORIGINAL

MODIFIED
void f() { 

    int foo = b->a->bar->g();

    if(1) {

        foo = b->a->bar->g();
        blah;

    }

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact#: #Statement# = #3#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• name change from 'a' to 'b->a'
	• name change from 'f' to 'g'

END_SUMMARY

### Test 8 ###
ORIGINAL
void f() { 

    int foo = bar->f();

    if(1) {

        foo = bar->f();
        blah;

    }

}
END_ORIGINAL

MODIFIED
void f() { 

    int foo = b->bar->g();

    if(1) {

        foo = b->bar->g();
        blah;

    }

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact#: #Statement# = #3#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• name change from 'bar' to 'b->bar'
	• name change from 'f' to 'g'

END_SUMMARY
