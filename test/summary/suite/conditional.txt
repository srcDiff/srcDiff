### Test 1 ###
ORIGINAL
void f() {

	if(1) {}

}
END_ORIGINAL

MODIFIED
void f() {

	if(2) {}

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f': Impact = High
	• the condition of a guard clause was changed from '1' to '2' within the function body

END_SUMMARY

### Test 2 ###
ORIGINAL
void TextTool::repaintSelection(int startPosition, int endPosition)
{
	if (startPosition > endPosition)
		qSwap(startPosition, endPosition);
	QList<TextShape *> shapes;
	KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(m_textShapeData->document()->documentLayout());
	Q_ASSERT(lay);
	foreach(KoShape* shape, lay->shapes()) {
		TextShape *textShape = dynamic_cast<TextShape*>(shape);
		Q_ASSERT(textShape);

		const int from = textShape->textShapeData()->position();
		const int end = textShape->textShapeData()->endPosition();
		if ((from <= startPosition && end >= startPosition && end <= endPosition)
			|| (from >= startPosition && end <= endPosition) // shape totally included
			|| (from <= endPosition && end >= endPosition)
			)
			shapes.append(textShape);
	}

	// loop over all shapes that contain the text and update per shape.
	QRectF repaintRect = textRect(startPosition, endPosition);
	foreach(TextShape *ts, shapes) {
		QRectF rect = repaintRect;
		rect.moveTop(rect.y() - ts->textShapeData()->documentOffset());
		rect = ts->absoluteTransformation(0).mapRect(rect);
		m_canvas->updateCanvas(ts->boundingRect().intersected(rect));
	}
}
END_ORIGINAL

MODIFIED
void TextTool::repaintSelection(int startPosition, int endPosition)
{
	if (startPosition == endPosition)
		return;
	if (startPosition > endPosition)
		qSwap(startPosition, endPosition);
	QList<TextShape *> shapes;
	KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(m_textShapeData->document()->documentLayout());
	Q_ASSERT(lay);
	foreach(KoShape* shape, lay->shapes()) {
		TextShape *textShape = dynamic_cast<TextShape*>(shape);
		if (textShape == 0) // when the shape is being deleted its no longer a TextShape but a KoShape
			continue;

		const int from = textShape->textShapeData()->position();
		const int end = textShape->textShapeData()->endPosition();
		if ((from <= startPosition && end >= startPosition && end <= endPosition)
			|| (from >= startPosition && end <= endPosition) // shape totally included
			|| (from <= endPosition && end >= endPosition)
			)
			shapes.append(textShape);
	}

	// loop over all shapes that contain the text and update per shape.
	QRectF repaintRect = textRect(startPosition, endPosition);
	foreach(TextShape *ts, shapes) {
		QRectF rect = repaintRect;
		rect.moveTop(rect.y() - ts->textShapeData()->documentOffset());
		rect = ts->absoluteTransformation(0).mapRect(rect);
		m_canvas->updateCanvas(ts->boundingRect().intersected(rect));
	}
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'TextTool::repaintSelection': Impact = Low
	• a guard clause was added to the function body
	• a call to 'Q_ASSERT' was replaced with a guard clause

END_SUMMARY

### Test 3 ###
ORIGINAL
void KoMainWindow::slotCloseAllViews()
{
	// Attention: Very touchy code... you know what you're doing? Goooood :)
	d->forQuit = true;
	if (queryClose()) {
		// In case the document is embedded we close all open "extra-shells"
		if (d->rootDoc && d->rootDoc->isEmbedded()) {
			hide();
			d->rootDoc->removeShell(this);
			QList<KoMainWindow*> shells = d->rootDoc->shells();
			while (!shells.isEmpty()) {
				KoMainWindow* window = shells.takeFirst();
				window->hide();
				delete window;
				d->rootDoc = 0;
			}
		}
		// not embedded -> destroy the document and all shells/views ;)
		else {
			setRootDocument(0);
		}
		close();  // close this window (and quit the app if necessary)
	}
	d->forQuit = false;
}
END_ORIGINAL

MODIFIED
void KoMainWindow::slotCloseAllViews()
{
	d->forQuit = true;
	if (queryClose()) {
		hide();
		d->rootDoc->removeShell(this);
		QList<KoMainWindow*> shells = d->rootDoc->shells();
		d->rootDoc = 0;
		while (!shells.isEmpty()) {
			KoMainWindow* window = shells.takeFirst();
			window->hide();
			delete window;
		}
		close();  // close this window (and quit the app if necessary)
	}
	d->forQuit = false;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KoMainWindow::slotCloseAllViews': Impact = Medium
	• an if statement with an else-clause and 2 of its 9 statements were removed with remaining 
	  code retained.  Then, the remaining code was modified
	  this modification included:
		• an assignment to 'd->rootDoc' was moved

END_SUMMARY

### Test 4 ###
ORIGINAL
KoView* KoMainWindow::currentView() const
{
    // XXX
    if (d->activeView) {
        return d->activeView;
    }
    else {
        return d->rootViews.first();
    }

}
END_ORIGINAL

MODIFIED
KoView* KoMainWindow::currentView() const
{
    // XXX
    if (d->activeView) {
        return d->activeView;
    }
    else if (!d->rootViews.isEmpty()) {
        return d->rootViews.first();
    }
    return 0;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KoMainWindow::currentView': Impact = High
	• an else statement was converted to an elseif statement
	  this includes:
		• an if statement was added around a return statement
	• a return statement was added to the function body

END_SUMMARY

### Test 5 ###
ORIGINAL
bool KisExifIO::loadFrom(KisMetaData::Store* store, QIODevice* ioDevice) const
{

    for (const_iterator it = exifData.begin(); it != exifData.end(); ++it) {

        if (it->key() == "MakerNote") {}
        else if (it->groupName() == "Photo" || (it->groupName() == "GPS")) {

            if( it->key() == "InteroperabilityTag" ) {}

        }

    }

}
END_ORIGINAL

MODIFIED
bool KisExifIO::loadFrom(KisMetaData::Store* store, QIODevice* ioDevice) const
{

    for (const_iterator it = exifData.begin(); it != exifData.end(); ++it) {

        if (it->key() == "MakerNote") {}
        else if (it->groupName() == "Photo" || (it->groupName() == "GPS")) {

            if( it->key() == "InteroperabilityTag" || it->key() == "0xea1d" ) {}

        }

    }

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KisExifIO::loadFrom': Impact = High
	• the condition of a guard clause was changed adding the clause '|| it->key() == "0xea1'

END_SUMMARY

### Test 6 ###
ORIGINAL
void KisGroupLayer::resetProjection(KisPaintDeviceSP to)
{
    if (to)
        m_d->projection = new KisPaintDevice(*to); /// XXX ### look into Copy on Write here (CoW)
    else
        m_d->projection = new KisPaintDevice(this, image()->colorSpace());
}
END_ORIGINAL

MODIFIED
void KisGroupLayer::resetProjection(KisPaintDeviceSP to)
{
    if (to)
        m_d->projection = new KisPaintDevice(*to); /// XXX ### look into Copy on Write here (CoW)
    else if( *m_d->projection->colorSpace() == *image()->colorSpace())
        m_d->projection->clear();
    else
        m_d->projection = new KisPaintDevice(this, image()->colorSpace());
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KisGroupLayer::resetProjection': Impact = High
	• an elseif statement with a single statement was added

END_SUMMARY

### Test 7 ###
ORIGINAL
RotateImage::RotateImage(QObject *parent, const QStringList &)
        : KParts::Plugin(parent)
{
    if (parent->inherits("KisView2")) {
        action  = new KAction(i18n("&Rotate Layer..."), this);
        actionCollection()->addAction("rotatelayer", action);
        connect(action, SIGNAL(triggered()), this, SLOT(slotRotateLayer()));

        action  = new KAction(i18nc("rotate the layer 180 degrees", "1&80Â°"), this);
        actionCollection()->addAction("rotateLayer180", action);
        connect(action, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayer180()));

        action  = new KAction(KIcon("object-rotate-right"), i18nc("rotate the layer 90 degrees to the right", "Right 90Â°"), this);
        actionCollection()->addAction("rotateLayerCW90", action);
        connect(action, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerRight90()));

        action  = new KAction(KIcon("object-rotate-left"), i18nc("rotate the layer 90 degrees to the left", "Left 90Â°"), this);
        actionCollection()->addAction("rotateLayerCCW90", action);
        connect(action, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerLeft90()));
    }
}
END_ORIGINAL

MODIFIED
RotateImage::RotateImage(QObject *parent, const QStringList &)
        : KParts::Plugin(parent)
{
    if (parent->inherits("KisView2")) {
        m_rotateLayerAction  = new KAction(i18n("&Rotate Layer..."), this);
        actionCollection()->addAction("rotatelayer", m_rotateLayerAction);
        connect(m_rotateLayerAction, SIGNAL(triggered()), this, SLOT(slotRotateLayer()));

        m_rotate90LayerAction  = new KAction(i18nc("rotate the layer 180 degrees", "1&80Â°"), this);
        actionCollection()->addAction("rotateLayer180", m_rotate90LayerAction);
        connect(m_rotate90LayerAction, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayer180()));

        m_rotate180LayerAction  = new KAction(KIcon("object-rotate-right"), i18nc("rotate the layer 90 degrees to the right", "Right 90Â°"), this);
        actionCollection()->addAction("rotateLayerCW90", m_rotate180LayerAction);
        connect(m_rotate180LayerAction, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerRight90()));

        m_rotate270LayerAction  = new KAction(KIcon("object-rotate-left"), i18nc("rotate the layer 90 degrees to the left", "Left 90Â°"), this);
        actionCollection()->addAction("rotateLayerCCW90", m_rotate270LayerAction);
        connect(m_rotate270LayerAction, SIGNAL(triggered()), m_view->layerManager(), SLOT(rotateLayerLeft90()));

        connect(m_view->resourceProvider(), SIGNAL(sigNodeChanged(const KisNodeSP)), SLOT(slotNodeChanged(KisNodeSP)));
    }
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• constructor 'RotateImage::RotateImage': Impact = High
	• the body of an if statement was modified
	  this modification included:
		• the identifier 'action'  was replaced with 'm_rotate180LayerAction' in several 
		  places
		• the identifier 'action'  was replaced with 'm_rotate270LayerAction' in 
		  several places
		• the identifier 'action'  was replaced with 'm_rotate90LayerAction' in several 
		  places
		• the identifier 'action'  was replaced with 'm_rotateLayerAction' in 
		  several places
		• a call to 'connect' was added

END_SUMMARY
