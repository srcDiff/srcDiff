### Test 1 ###
ORIGINAL
void f() {

	if(1) {}

}
END_ORIGINAL

MODIFIED
void f() {

	if(2) {}

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f': Impact = High
	• the condition of a guard clause was changed from '1' to '2' within the function body

END_SUMMARY

### Test 2 ###
ORIGINAL
void TextTool::repaintSelection(int startPosition, int endPosition)
{
	if (startPosition > endPosition)
		qSwap(startPosition, endPosition);
	QList<TextShape *> shapes;
	KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(m_textShapeData->document()->documentLayout());
	Q_ASSERT(lay);
	foreach(KoShape* shape, lay->shapes()) {
		TextShape *textShape = dynamic_cast<TextShape*>(shape);
		Q_ASSERT(textShape);

		const int from = textShape->textShapeData()->position();
		const int end = textShape->textShapeData()->endPosition();
		if ((from <= startPosition && end >= startPosition && end <= endPosition)
			|| (from >= startPosition && end <= endPosition) // shape totally included
			|| (from <= endPosition && end >= endPosition)
			)
			shapes.append(textShape);
	}

	// loop over all shapes that contain the text and update per shape.
	QRectF repaintRect = textRect(startPosition, endPosition);
	foreach(TextShape *ts, shapes) {
		QRectF rect = repaintRect;
		rect.moveTop(rect.y() - ts->textShapeData()->documentOffset());
		rect = ts->absoluteTransformation(0).mapRect(rect);
		m_canvas->updateCanvas(ts->boundingRect().intersected(rect));
	}
}
END_ORIGINAL

MODIFIED
void TextTool::repaintSelection(int startPosition, int endPosition)
{
	if (startPosition == endPosition)
		return;
	if (startPosition > endPosition)
		qSwap(startPosition, endPosition);
	QList<TextShape *> shapes;
	KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(m_textShapeData->document()->documentLayout());
	Q_ASSERT(lay);
	foreach(KoShape* shape, lay->shapes()) {
		TextShape *textShape = dynamic_cast<TextShape*>(shape);
		if (textShape == 0) // when the shape is being deleted its no longer a TextShape but a KoShape
			continue;

		const int from = textShape->textShapeData()->position();
		const int end = textShape->textShapeData()->endPosition();
		if ((from <= startPosition && end >= startPosition && end <= endPosition)
			|| (from >= startPosition && end <= endPosition) // shape totally included
			|| (from <= endPosition && end >= endPosition)
			)
			shapes.append(textShape);
	}

	// loop over all shapes that contain the text and update per shape.
	QRectF repaintRect = textRect(startPosition, endPosition);
	foreach(TextShape *ts, shapes) {
		QRectF rect = repaintRect;
		rect.moveTop(rect.y() - ts->textShapeData()->documentOffset());
		rect = ts->absoluteTransformation(0).mapRect(rect);
		m_canvas->updateCanvas(ts->boundingRect().intersected(rect));
	}
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'TextTool::repaintSelection': Impact = Low
	• a guard clause was added to the function body
	• a call to 'Q_ASSERT' was replaced with a guard clause

END_SUMMARY

### Test 3 ###
ORIGINAL
void KoMainWindow::slotCloseAllViews()
{
	// Attention: Very touchy code... you know what you're doing? Goooood :)
	d->forQuit = true;
	if (queryClose()) {
		// In case the document is embedded we close all open "extra-shells"
		if (d->rootDoc && d->rootDoc->isEmbedded()) {
			hide();
			d->rootDoc->removeShell(this);
			QList<KoMainWindow*> shells = d->rootDoc->shells();
			while (!shells.isEmpty()) {
				KoMainWindow* window = shells.takeFirst();
				window->hide();
				delete window;
				d->rootDoc = 0;
			}
		}
		// not embedded -> destroy the document and all shells/views ;)
		else {
			setRootDocument(0);
		}
		close();  // close this window (and quit the app if necessary)
	}
	d->forQuit = false;
}
END_ORIGINAL

MODIFIED
void KoMainWindow::slotCloseAllViews()
{
	d->forQuit = true;
	if (queryClose()) {
		hide();
		d->rootDoc->removeShell(this);
		QList<KoMainWindow*> shells = d->rootDoc->shells();
		d->rootDoc = 0;
		while (!shells.isEmpty()) {
			KoMainWindow* window = shells.takeFirst();
			window->hide();
			delete window;
		}
		close();  // close this window (and quit the app if necessary)
	}
	d->forQuit = false;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KoMainWindow::slotCloseAllViews': Impact = Medium
	• an if statement with 9 statements and with an else-clause was removed with the 
	  if-statement's body taken from around existing code.  Then, the existing code was modified
	  this modification included:
		• an assignment to 'd->rootDoc' was added
		• an assignment to 'd->rootDoc' was deleted from a nested while statement

END_SUMMARY

### Test 4 ###
ORIGINAL
KoView* KoMainWindow::currentView() const
{
    // XXX
    if (d->activeView) {
        return d->activeView;
    }
    else {
        return d->rootViews.first();
    }

}
END_ORIGINAL

MODIFIED
KoView* KoMainWindow::currentView() const
{
    // XXX
    if (d->activeView) {
        return d->activeView;
    }
    else if (!d->rootViews.isEmpty()) {
        return d->rootViews.first();
    }
    return 0;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KoMainWindow::currentView': Impact = High
	• an else statement was converted to an elseif statement
	  this includes:
		• an if statement was added around a return statement
	• a return statement was added to the function body

END_SUMMARY

### Test 5 ###
ORIGINAL
bool KisExifIO::loadFrom(KisMetaData::Store* store, QIODevice* ioDevice) const
{

    for (const_iterator it = exifData.begin(); it != exifData.end(); ++it) {

        if (it->key() == "MakerNote") {}
        else if (it->groupName() == "Photo" || (it->groupName() == "GPS")) {

            if( it->key() == "InteroperabilityTag" ) {}

        }

    }

}
END_ORIGINAL

MODIFIED
bool KisExifIO::loadFrom(KisMetaData::Store* store, QIODevice* ioDevice) const
{

    for (const_iterator it = exifData.begin(); it != exifData.end(); ++it) {

        if (it->key() == "MakerNote") {}
        else if (it->groupName() == "Photo" || (it->groupName() == "GPS")) {

            if( it->key() == "InteroperabilityTag" || it->key() == "0xea1d" ) {}

        }

    }

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KisExifIO::loadFrom': Impact = High
	• the condition of a guard clause was was changed adding the clause '|| it->key() == 
	  "0xea1'

END_SUMMARY

### Test 6 ###
ORIGINAL
void KisGroupLayer::resetProjection(KisPaintDeviceSP to)
{
    if (to)
        m_d->projection = new KisPaintDevice(*to); /// XXX ### look into Copy on Write here (CoW)
    else
        m_d->projection = new KisPaintDevice(this, image()->colorSpace());
}
END_ORIGINAL

MODIFIED
void KisGroupLayer::resetProjection(KisPaintDeviceSP to)
{
    if (to)
        m_d->projection = new KisPaintDevice(*to); /// XXX ### look into Copy on Write here (CoW)
    else if( *m_d->projection->colorSpace() == *image()->colorSpace())
        m_d->projection->clear();
    else
        m_d->projection = new KisPaintDevice(this, image()->colorSpace());
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KisGroupLayer::resetProjection': Impact = High
	• an elseif statement with a single statement was added

END_SUMMARY