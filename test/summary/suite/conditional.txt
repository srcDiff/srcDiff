### Test 1 ###
ORIGINAL
void f() {

	if(1) {}

}
END_ORIGINAL

MODIFIED
void f() {

	if(2) {}

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f':
  #Impact#: #Statement# = #1#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• the condition of a #guard clause# was modified

END_SUMMARY

### Test 2 ###
ORIGINAL
void TextTool::repaintSelection(int startPosition, int endPosition)
{
	if (startPosition > endPosition)
		qSwap(startPosition, endPosition);
	QList<TextShape *> shapes;
	KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(m_textShapeData->document()->documentLayout());
	Q_ASSERT(lay);
	foreach(KoShape* shape, lay->shapes()) {
		TextShape *textShape = dynamic_cast<TextShape*>(shape);
		Q_ASSERT(textShape);

		const int from = textShape->textShapeData()->position();
		const int end = textShape->textShapeData()->endPosition();
		if ((from <= startPosition && end >= startPosition && end <= endPosition)
			|| (from >= startPosition && end <= endPosition) // shape totally included
			|| (from <= endPosition && end >= endPosition)
			)
			shapes.append(textShape);
	}

	// loop over all shapes that contain the text and update per shape.
	QRectF repaintRect = textRect(startPosition, endPosition);
	foreach(TextShape *ts, shapes) {
		QRectF rect = repaintRect;
		rect.moveTop(rect.y() - ts->textShapeData()->documentOffset());
		rect = ts->absoluteTransformation(0).mapRect(rect);
		m_canvas->updateCanvas(ts->boundingRect().intersected(rect));
	}
}
END_ORIGINAL

MODIFIED
void TextTool::repaintSelection(int startPosition, int endPosition)
{
	if (startPosition == endPosition)
		return;
	if (startPosition > endPosition)
		qSwap(startPosition, endPosition);
	QList<TextShape *> shapes;
	KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(m_textShapeData->document()->documentLayout());
	Q_ASSERT(lay);
	foreach(KoShape* shape, lay->shapes()) {
		TextShape *textShape = dynamic_cast<TextShape*>(shape);
		if (textShape == 0) // when the shape is being deleted its no longer a TextShape but a KoShape
			continue;

		const int from = textShape->textShapeData()->position();
		const int end = textShape->textShapeData()->endPosition();
		if ((from <= startPosition && end >= startPosition && end <= endPosition)
			|| (from >= startPosition && end <= endPosition) // shape totally included
			|| (from <= endPosition && end >= endPosition)
			)
			shapes.append(textShape);
	}

	// loop over all shapes that contain the text and update per shape.
	QRectF repaintRect = textRect(startPosition, endPosition);
	foreach(TextShape *ts, shapes) {
		QRectF rect = repaintRect;
		rect.moveTop(rect.y() - ts->textShapeData()->documentOffset());
		rect = ts->absoluteTransformation(0).mapRect(rect);
		m_canvas->updateCanvas(ts->boundingRect().intersected(rect));
	}
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'TextTool::repaintSelection':
  #Impact#: #Statement# = #6#	#Non-Statement# = #0#	#Cyclomatic# = #+2#
	• a #guard clause# was inserted
	• a #call# was replaced with a #guard clause#

END_SUMMARY

### Test 3 ###
ORIGINAL
void KoMainWindow::slotCloseAllViews()
{
	// Attention: Very touchy code... you know what you're doing? Goooood :)
	d->forQuit = true;
	if (queryClose()) {
		// In case the document is embedded we close all open "extra-shells"
		if (d->rootDoc && d->rootDoc->isEmbedded()) {
			hide();
			d->rootDoc->removeShell(this);
			QList<KoMainWindow*> shells = d->rootDoc->shells();
			while (!shells.isEmpty()) {
				KoMainWindow* window = shells.takeFirst();
				window->hide();
				delete window;
				d->rootDoc = 0;
			}
		}
		// not embedded -> destroy the document and all shells/views ;)
		else {
			setRootDocument(0);
		}
		close();  // close this window (and quit the app if necessary)
	}
	d->forQuit = false;
}
END_ORIGINAL

MODIFIED
void KoMainWindow::slotCloseAllViews()
{
	d->forQuit = true;
	if (queryClose()) {
		hide();
		d->rootDoc->removeShell(this);
		QList<KoMainWindow*> shells = d->rootDoc->shells();
		d->rootDoc = 0;
		while (!shells.isEmpty()) {
			KoMainWindow* window = shells.takeFirst();
			window->hide();
			delete window;
		}
		close();  // close this window (and quit the app if necessary)
	}
	d->forQuit = false;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KoMainWindow::slotCloseAllViews':
  #Impact#: #Statement# = #6#	#Non-Statement# = #0#	#Cyclomatic# = #-1#
	• an #if-else# was deleted
	• an #assignment# was moved

END_SUMMARY

### Test 4 ###
ORIGINAL
KoView* KoMainWindow::currentView() const
{
    // XXX
    if (d->activeView) {
        return d->activeView;
    }
    else {
        return d->rootViews.first();
    }

}
END_ORIGINAL

MODIFIED
KoView* KoMainWindow::currentView() const
{
    // XXX
    if (d->activeView) {
        return d->activeView;
    }
    else if (!d->rootViews.isEmpty()) {
        return d->rootViews.first();
    }
    return 0;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KoMainWindow::currentView':
  #Impact#: #Statement# = #3#	#Non-Statement# = #0#	#Cyclomatic# = #+1#
	• an #else# was converted to an #else if#
	• a #return# was inserted

END_SUMMARY

### Test 5 ###
ORIGINAL
bool KisExifIO::loadFrom(KisMetaData::Store* store, QIODevice* ioDevice) const
{

    for (const_iterator it = exifData.begin(); it != exifData.end(); ++it) {

        if (it->key() == "MakerNote") {}
        else if (it->groupName() == "Photo" || (it->groupName() == "GPS")) {

            if( it->key() == "InteroperabilityTag" ) {}

        }

    }

}
END_ORIGINAL

MODIFIED
bool KisExifIO::loadFrom(KisMetaData::Store* store, QIODevice* ioDevice) const
{

    for (const_iterator it = exifData.begin(); it != exifData.end(); ++it) {

        if (it->key() == "MakerNote") {}
        else if (it->groupName() == "Photo" || (it->groupName() == "GPS")) {

            if( it->key() == "InteroperabilityTag" || it->key() == "0xea1d" ) {}

        }

    }

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KisExifIO::loadFrom':
  #Impact#: #Statement# = #4#	#Non-Statement# = #0#	#Cyclomatic# = #0#
	• the condition of a #guard clause# was modified

END_SUMMARY

### Test 6 ###
ORIGINAL
void KisGroupLayer::resetProjection(KisPaintDeviceSP to)
{
    if (to)
        m_d->projection = new KisPaintDevice(*to); /// XXX ### look into Copy on Write here (CoW)
    else
        m_d->projection = new KisPaintDevice(this, image()->colorSpace());
}
END_ORIGINAL

MODIFIED
void KisGroupLayer::resetProjection(KisPaintDeviceSP to)
{
    if (to)
        m_d->projection = new KisPaintDevice(*to); /// XXX ### look into Copy on Write here (CoW)
    else if( *m_d->projection->colorSpace() == *image()->colorSpace())
        m_d->projection->clear();
    else
        m_d->projection = new KisPaintDevice(this, image()->colorSpace());
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KisGroupLayer::resetProjection':
  #Impact#: #Statement# = #3#	#Non-Statement# = #0#	#Cyclomatic# = #+1#
	• an #else if# was inserted

END_SUMMARY

### Test 7 ###
ORIGINAL
void KWView::formatPage()
{
    if (! m_currentPage.isValid())
        return;
    KWPageSettingsDialog *dia = new KWPageSettingsDialog(this, m_document, m_currentPage);
    dia->showTextDirection(kwcanvas()->resourceProvider()->boolResource(KoText::BidiDocument));

    dia->show();
}
END_ORIGINAL

MODIFIED
void KWView::formatPage()
{
    if (! m_currentPage.isValid())
        return;
    KWPageSettingsDialog *dia = new KWPageSettingsDialog(this, m_document, m_currentPage);
    if (m_document->mainFrameSet()) {
        KoTextDocument doc(m_document->mainFrameSet()->document());
        KoTextEditor *editor = doc.textEditor();
        if (editor)
                dia->showTextDirection(editor->isBidiDocument());

    }
    dia->show();
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KWView::formatPage':
  #Impact#: #Statement# = #5#	#Non-Statement# = #0#	#Cyclomatic# = #+2#
	• an #if# was inserted
	• an #argument# was modified

END_SUMMARY

### Test 8 ###
ORIGINAL
KWTextFrameSet::~KWTextFrameSet()
{
	delete m_document;
}
END_ORIGINAL

MODIFIED
KWTextFrameSet::~KWTextFrameSet()
{
	// first remove the doc from all our frames so they won't try to use it after we delete it.
	if (m_frames.isEmpty()) {
		delete m_document;
	} else {
		// we transfer ownership of the doc to our last shape so it will keep being alive until nobody references it anymore.
		KoTextShapeData *tsd = qobject_cast<KoTextShapeData*>(m_frames.last()->shape()->userData());
		Q_ASSERT(tsd);
		tsd->setDocument(m_document);
		m_document = 0;
	}
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• destructor 'KWTextFrameSet::~KWTextFrameSet':
  #Impact#: #Statement# = #5#	#Non-Statement# = #0#	#Cyclomatic# = #+1#
	• an #if-else# was inserted

END_SUMMARY