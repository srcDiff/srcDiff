### Test 1 ###
ORIGINAL
void f() {

	if(1) {}

}
END_ORIGINAL

MODIFIED
void f() {

	if(2) {}

}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'f': Impact = High
	• the condition of a guard clause was modified
	  this modification included:
		• the condition was changed from '1' to '2'

END_SUMMARY

### Test 2 ###
ORIGINAL
void TextTool::repaintSelection(int startPosition, int endPosition)
{
	if (startPosition > endPosition)
		qSwap(startPosition, endPosition);
	QList<TextShape *> shapes;
	KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(m_textShapeData->document()->documentLayout());
	Q_ASSERT(lay);
	foreach(KoShape* shape, lay->shapes()) {
		TextShape *textShape = dynamic_cast<TextShape*>(shape);
		Q_ASSERT(textShape);

		const int from = textShape->textShapeData()->position();
		const int end = textShape->textShapeData()->endPosition();
		if ((from <= startPosition && end >= startPosition && end <= endPosition)
			|| (from >= startPosition && end <= endPosition) // shape totally included
			|| (from <= endPosition && end >= endPosition)
			)
			shapes.append(textShape);
	}

	// loop over all shapes that contain the text and update per shape.
	QRectF repaintRect = textRect(startPosition, endPosition);
	foreach(TextShape *ts, shapes) {
		QRectF rect = repaintRect;
		rect.moveTop(rect.y() - ts->textShapeData()->documentOffset());
		rect = ts->absoluteTransformation(0).mapRect(rect);
		m_canvas->updateCanvas(ts->boundingRect().intersected(rect));
	}
}
END_ORIGINAL

MODIFIED
void TextTool::repaintSelection(int startPosition, int endPosition)
{
	if (startPosition == endPosition)
		return;
	if (startPosition > endPosition)
		qSwap(startPosition, endPosition);
	QList<TextShape *> shapes;
	KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(m_textShapeData->document()->documentLayout());
	Q_ASSERT(lay);
	foreach(KoShape* shape, lay->shapes()) {
		TextShape *textShape = dynamic_cast<TextShape*>(shape);
		if (textShape == 0) // when the shape is being deleted its no longer a TextShape but a KoShape
			continue;

		const int from = textShape->textShapeData()->position();
		const int end = textShape->textShapeData()->endPosition();
		if ((from <= startPosition && end >= startPosition && end <= endPosition)
			|| (from >= startPosition && end <= endPosition) // shape totally included
			|| (from <= endPosition && end >= endPosition)
			)
			shapes.append(textShape);
	}

	// loop over all shapes that contain the text and update per shape.
	QRectF repaintRect = textRect(startPosition, endPosition);
	foreach(TextShape *ts, shapes) {
		QRectF rect = repaintRect;
		rect.moveTop(rect.y() - ts->textShapeData()->documentOffset());
		rect = ts->absoluteTransformation(0).mapRect(rect);
		m_canvas->updateCanvas(ts->boundingRect().intersected(rect));
	}
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'TextTool::repaintSelection': Impact = Low
	• a guard clause was added to the function body
	• the body of a foreach statement was modified
	  this modification included:
		• a call to 'Q_ASSERT' was replaced with a guard clause

END_SUMMARY

### Test 3 ###
ORIGINAL
void KoMainWindow::slotCloseAllViews()
{
	// Attention: Very touchy code... you know what you're doing? Goooood :)
	d->forQuit = true;
	if (queryClose()) {
		// In case the document is embedded we close all open "extra-shells"
		if (d->rootDoc && d->rootDoc->isEmbedded()) {
			hide();
			d->rootDoc->removeShell(this);
			QList<KoMainWindow*> shells = d->rootDoc->shells();
			while (!shells.isEmpty()) {
				KoMainWindow* window = shells.takeFirst();
				window->hide();
				delete window;
				d->rootDoc = 0;
			}
		}
		// not embedded -> destroy the document and all shells/views ;)
		else {
			setRootDocument(0);
		}
		close();  // close this window (and quit the app if necessary)
	}
	d->forQuit = false;
}
END_ORIGINAL

MODIFIED
void KoMainWindow::slotCloseAllViews()
{
	d->forQuit = true;
	if (queryClose()) {
		hide();
		d->rootDoc->removeShell(this);
		QList<KoMainWindow*> shells = d->rootDoc->shells();
		d->rootDoc = 0;
		while (!shells.isEmpty()) {
			KoMainWindow* window = shells.takeFirst();
			window->hide();
			delete window;
		}
		close();  // close this window (and quit the app if necessary)
	}
	d->forQuit = false;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KoMainWindow::slotCloseAllViews': Impact = Medium
	• the body of an if statement was modified
	  this modification included:
		• an if statement with 10 statements and with an else-clause was removed with the 
		  if-statement's body taken from around existing code.  Then, the existing code was modified
		  this modification included:
			• an assignment to 'd->rootDoc' was added
			• the body of a while statement was modified
			  this modification included:
				• an assignment to 'd->rootDoc' was deleted

END_SUMMARY

### Test 4 ###
ORIGINAL
KoView* KoMainWindow::currentView() const
{
    // XXX
    if (d->activeView) {
        return d->activeView;
    }
    else {
        return d->rootViews.first();
    }

}
END_ORIGINAL

MODIFIED
KoView* KoMainWindow::currentView() const
{
    // XXX
    if (d->activeView) {
        return d->activeView;
    }
    else if (!d->rootViews.isEmpty()) {
        return d->rootViews.first();
    }
    return 0;
}
END_MODIFIED

SUMMARY
• file 'original.cpp|modified.cpp': Impact = High

• Modified function(s): 1
• function 'KoMainWindow::currentView': Impact = High
	• an else statement was converted to an elseif statement
	  this includes:
		• an if statement with a single statement was added around a return statement
	• a return statement was added to the function body

END_SUMMARY
